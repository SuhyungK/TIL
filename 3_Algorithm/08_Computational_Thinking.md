# 23_Computational Thinking

## 목차

1. [서론 - 프로그래밍 논리](https://github.com/SuhyungK/TIL/blob/master/3_Algorithm/08_Computational_Thinking.md#%EC%84%9C%EB%AC%B8)
2. [논리와 증명](https://github.com/SuhyungK/TIL/blob/master/3_Algorithm/08_Computational_Thinking.md#%EB%85%BC%EB%A6%AC%EC%99%80-%EC%A6%9D%EB%AA%85)
3. [수와 표현](https://github.com/SuhyungK/TIL/blob/master/3_Algorithm/08_Computational_Thinking.md#%EC%88%98%EC%99%80-%ED%91%9C%ED%98%84)
4. 집합과 조합론
5. 기초 수식
6. 재귀
7. 동적 프로그래밍


## 서문

- 정확하게 확인하고 문제 풀이를 하는 게 중요
- 쉬운 문제를 보고 증명을 확인해보는 연습이 필요

- 프로그래밍은 *Hard Logic*을 사용
    - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
    - 사용되는 수많은 알고리즘들을 이해하기 위해서는 *Hard Logic*이 필요

### 명제

- 참이나 거짓을 알 수 있는 식이나 문장
- *p, q, r…* 로 표현
    - 서울은 대한민국의 수도다
    - 1 + 1 ≠ 3

- **진릿값**
    - 참이나 거짓 표현
    - T, F 또는 1, 0
- **부정 NOT**
    - *p*가 명제일 때, 명제의 진릿값이 반대
    - *~p*
- **논리곱 AND**
    - *p, q*가 명제일 때, *p, q*가 모두 참일 때만 참
    - *p^q*
- **논리합 OR**
    - *p, q*가 명제일 때, *p, q* 모두 거짓일 때만 거짓이 되는 명제
    - *p V q*
- **배타적 논리합 XOR**
    - *p, q*가 명제일 때, *p, q* 중 하나만 참일 때 참이 되는 명제
    - *p xor q*

### 연산자 우선 순위

- NOT > AND, OR > → ↔

### 명제의 종류

- 조건 명제
    - p, q가 명제일 때, 명제 p가 조건(또는 원인), q가 결론(또는 결과)로 제시되는 명제
    - p → q
    - p가 F면 p → q : T
    - q가 T면 p → q :  T

- 쌍방조건명제
    - p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
    - p ↔ q (p면 q고, q면 p다)

- 조건 명제의 역, 이, 대우

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c889482-185b-4fc2-a8a7-9dc69ab210b8/Untitled.png)

## 증명

- 정확한 명제식으로 표현할 수 있는 것이여야 함
- 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음

## 수학적 귀납법

- $P(1)$이 참이고, $P(n) → P(n+1)$이 참이면 $P(n)$은 모든 자연수 $n$에 대해서 참

## 논리와 증명

### 문제 6 $(직접 증명)n이 짝수이면 3n+5는 홀수임을 증명하라$

$n = 2k(k는 1보다 큰 자연수)$

$3n+5 = 3*2k+5 = 2*3k + 2*2 + 1 = 2*(3k+2)+1 = 2*n’ +1$

$2*(자연수)+1 ⇒ 홀수$무

## 수와 표현

- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현 → 컴퓨터 구조
- *k*개의 비트를 사용하면 0 부터 **$2^k-1$까지 표현 가능
- 어떤 경우든 최대 $2^k$ **가지의 값을 표현하는 것이 가능
- 10진수로 *k*자리를 쓰면 0부터 $10^k-1$까지 표현가능한 것과 완전 동일
- 어떤 값 n을 표현하기 위해서 몇 개의 비트(자리 수)가 필요할까?
    - $2^k-1$≥ n이 성립해야 함 → $2^k$≥ n+1
    - 같은 의미로, k ≥ *log(n+1)*  → 약 log n 비트가 필요

- *log n*
    1. 2의 몇 승이 n이 되느냐
    2. n을 표현하는 데 몇 비트가 필요한가
    3. 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐
    4. n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐   
    - *cf) 컴퓨터 분야에서 로그의 밑은 항상 2*
    

## 귀류법

- 어떤 명제가 참임을 증명하려 할 때 그 명제의 결론을 부정함으로써 가정(假定) 또는 공리(公理) 등이 모순됨을 보여 간접적으로 그 결론이 성립한다는 것을 증명하는 방법이다.

## 집합과 조합론

- 두 집합 A와 B에 대해 A가 B의 부분집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같음
- 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분 집합이고 B가 A의 부분 집합임을 증명하면 됨

## 기초 수식

- 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식 존재
- 풀이법을 익혀 둬야 알고리즘의 시간 복잡도를 계산할 수 있음
- 알고리즘의 시간이 얼마나 걸릴 지 예측할 수 있음

## 재귀

- 자기 자신을 호출하는 함수
- 함수는 입력이 있으며, 자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면 끝나지 않음
- 하지만, 다른 입력으로 호출하면 끝날 수 있음
- 수학적 귀납법 증명 사용 가능
    - n이 0일 때 문제를 풀 수 있음
    - n-1에서 문제를 풀 수 있으면 n에서도 문제를 풀 수 있음
    - ⇒ 두 가지가 사실이면 모든 가능한 n에 대해 문제를 풀 수 있음

## 동적 프로그래밍

- 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해 두고 불러 쓰는 것 (*Memoization)*
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리 필요
- 단순히 재귀에서 저장된 값을 찾아보는 것도 가능하지만, 결과 값을 순서로 정해서 계산할 수도 있음(*Dynamic Programming)*