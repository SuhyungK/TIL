# **스택**

- 스택
- 재귀호출
- Memoization
- DP
- DFS

## **스택**

- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조(저장하는 방법)
- 스택에 저장된 자료는 선형 구조를 가짐
    - 선형구조 : 자료 간의 관계가 1대 1
    - 비선형구조 : 자료 간의 관계가 1대 N
- 스택에 자료를 삽입하거나 꺼낼 수 있음
- 마지막에 삽입한 자료 가장 먼저 꺼냄 = 후입선출(LIFO, Last In First Out)
- 자료구조 스택으로 선언했으면 중간 자료 꺼내지 X

### **자료구조와 연산**

- 자료구조 : 자료를 선형으로 저장할 저장소
    - 배열 사용 가능
    - 저장소 자체를 스택이라 부름
    - 마지막 삽입된 원소의 위치를 top(stack pointer, sp)라 부름
- 연산
    - 삽입 : 저장소에 자료를 저장 `push` (어셈블리어에서 유래)
    - 삭제 : 저장소에서 자료를 꺼냄, 꺼낸 자료는 삽입한 자료 역순으로 꺼냄 `pop`
    - `isEmpty` : 스택이 공백인지 아닌지 확인하는 연산
        - 비어 있으면 True, 비어 있지 않으면 False
    - `peek` : 스택이 top에 있는 item(원소)를 반환하는 연산

### **스택의 삽입/삭제 과정**

- 빈 스택에 원소 A, B, C를 차례로 삽입 후 한 번 삭제하는 연산 과정
- 공백 상태에서 top은 가장 밑바닥보다 아래
- A를 push하게 되면 A가 top
    - push : top 증가 (`top++` `stack[top] = A`)
- pop : top에 있던 원소를 삭제하고 top 한 칸 아래로
    - 따로 정의 X, top이 올라갔다 내려가면서 강제로 덮어씌워짐

## **스택의 push 알고리즘**

- append 메소드를 통해 리스트의 마지막에 데이터 삽입

```python
def push(item):
    s.append(item)

# 형식을 갖춘 경우
def push(item, size):
    global top
    top += 1 # push할 때 top 하나 증가시켜서 그 자리에 저장
    if top == size: # 디버깅용 - 최상단까지 올라가서 꽉 찬 상태
        print('overflow!')
    else:
        stack[top] = item

size = 10 # 크기 정해서 만드는 게 가장 무난
stack = [0] * size
top = -1 # 밑바닥보다 더 아래

# 형식 없이 그냥 쓰는 경우
top += 1 # push(20)
stack[top] = 20
```

- 리스트의 append와 pop은 느리기 때문에 형식을 정해서 사용하길 권장

## **스택의 pop 알고리즘**

```python
def pop():
    if len(s) == 0:
        # underflow : 더 이상 pop 할 게 없는 경우
        # print('underflow!')
        return
    else:
        return s.pop()

# 크기를 정해놓고 구현하는 경우
def pop():
    global top
    if top == 1:
        print('underflow')
        return 0 
    else:
        top -= 1
        return stack[top+1] # return stack[top--]

print(pop())

if pop > -1:
    top -= 1
    print(stack[top+1])
```

- BFS 탐색에서 underflow 발생하는 경우 뭔가 코드가 잘못된 것

## **스택 구현 고려 사항**

- 1차원 배열 사용하여 구현할 경우 구현 용이
- 스택 크기를 변경하기 어렵다는 단점
- 해결 방법 : 동적 할당 = 연결리스트 -> 메모리 효율적으로 사용

## **스택의 응용**

### **괄호 검사**

- 괄호의 종류 : 대괄호, 중괄호, 소괄호
    - 왼쪽 괄호 오른쪽 괄호 개수 같아야 함
    - 왼쪽 괄호가 오른쪽 괄호보다 먼저
    - 괄호 사이에는 포함 관계만 존재

### **스택을 활용한 괄호 검사**

- 문자열에 있는 괄호 차례대로 조사하면서 왼쪽 괄호 만나면 스택에 삽입,
- 오른쪽 괄호 만나면 스택에서 top괄호 삭제한 후 오른쪽 괄호와 짝 맞는지 검사
- 괄호 수식이 끝났는데 스태에 괄호가 남아 있으면 오류
- 닫는 괄호가 나왔는데 스택이 끝나도 오류

### **Function call**

- 함수 호출
- 가장 마지막에 호출된 함수가 가장 먼저 실행 완료하고 복귀하는 후입선출 구조
- 함수 호출 발생 시 호출한 함수 수행에 필요한 지역변수, 매개변수 및 복귀할 주소 등의 정볼르 스택 프레임에 저장하여 시스템 스택에 삽입
- 함수 실행이 끝나면 시스템 스택에 있는 top원소를 삭제하면서 프레임에 저장되어 있던 복귀주소 확인 후 복귀
- 함수가 호출됐을 때 그 함수가 사용하는 영역이 stack

## **재귀호출**

- 자기 자신을 호출하여 순환 수행되는 것
- 내부 구조가 동일한 함수들을 호출할 때 재귀함수 호출 사용
- 함수를 호출할 때:
    - 그 함수를 동작을 시킨다
    - 이 함수가 사용할 메모리 영역을 따로 분리시킴
    - 호출할 때마다 서로 다른 메모리 영역 사용
- 함수 호출할 때마다 **서로 다른 메모리 영역을 사용**하며 호출될 때마다 그 메모리 영역으로 이동하기 때문에 동일한 함수를 계속 호출할 수 있음
- 재귀 ⇒ 백트래킹때 편함

```python
def fibo(n):
    # 피보나치 재귀함수 구현

def f(i, N): # i 현재 단계, N 목표 단계
    if i == N:
        print(i) # 목표치에서 할 일
        return
    else:
        print(i) # 재귀호출 전에 현재 할 일 알려 주는 것
        f(i+1, N)

f(0, 3)

"""
0
1
2
3 if i == N: print(i)에서 출력
"""
```

- 재귀 사용의 대부분이 배열에 접근하기 위한 것
- 백준 - [N과 M(1)](https://www.acmicpc.net/problem/15649), [N과 M(2](https://www.acmicpc.net/problem/15650))
- 재귀 호출의 깊이가 900~1000까지 접근하면 문제풀이가 잘못된 것일 가능성이 높음

```python
# 크기가 N인 배열의 모든 원소에 접근하는 재귀함수 기본형
def f(i, N):
    if i == N: # N = 3 이면 배열 벗어남, 모든 원소에 접근함
        return # 벗어나기
    else:      # 남은 원소가 있는 경우
        B[i] = A[i] # 남은 원소 B에 복사
        f(i+1, N) # 다음 원소로 이동
        
N = 3
A = [1, 2, 3]
B = [0] * N
f(0, N)    # 0번 원소부터 N개의 원소에 접근
print(B)
```

## **Memoization**

- 피보나치 수 구하는 함수 재귀함수로 사용하면 문제점이 있음
- 엄청난 중복 호출이 존재한다는 것
- 컴퓨터 프로그램 실행할 때 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술
- 동적 계획법(DP)의 핵심이 되는 기술, DP의 중간단계
- 피보나치의 값 계산하자마자 바로 저장하면(memoize) 실행시간을 O(n)으로 줄일 수 있음

```python
def fibo1(n):
    if n >= 2 and len(memo) <= n:
        memo.append(fibo1(n-1) + fibo1(n-2))
    return memo[n]
```

### **캐시(Cache)메모리**

- cpu와 main memory 중간단계에서 메모리 저장
- 속도는 빠르지만 조금 비쌈
- cache보다 빠르고 시스템 동작과 연관되는게 register(피연산자 저장, 주소 저장)
- `pc` : program counter
    - 어떤 줄에 접근해서 실행시킬 때 함수가 적혀 있으면 함수의 주소를 찾아가서 함수 실행
    - 그 다음에 실행됐어야 할 걸 스택에 저장하고 함수 실행 종료 후 스택을 찾아가서 저장된 함수를 실행

### **팩토리얼 재귀 구현**

```python
def f(n): # 팩토리얼 n! 1! = 1
    if n <= 1:
        return 1
    else:
        return n * f(n-1)

for i in range(21):
    print(f(i))
```

### **피보나치 구현**

```python
def fibo(n):
    if n < 2:
        return n
    return fibo(n-1) + fibo(n-2)

for i in range(101):
    print(i, fibo(i))

"""
33 3524578
34 5702887
35 9227465
36 14930352
37 24157817

중복 호출이 늘면서 속도가 굉장히 느려짐
"""
```

### **메모이제이션 추가 구현**

```python
def fibo(n):
    if memo[n] == -1: # 아직 한 번도 호출된 적이 없는 n이면
        memo[n] = fibo(n-1) + fibo(n-2)
    return memo[n]   # 호출된 적이 있는 n이면

memo = [-1] * 101
memo[0] = 0
memo[1] = 1

for i in range(101):
    print(i, fibo(i))

"""
97 83621143489848422977
98 135301852344706746049
99 218922995834555169026
100 354224848179261915075

끝까지 출력 가능
"""
```