# 13_분할정복_백트래킹

- [분할정복](https://github.com/SuhyungK/TIL/blob/master/3_Algorithm/13_%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5_%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9.md#%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EA%B8%B0%EB%B2%95)
- [퀵 정렬](https://github.com/SuhyungK/TIL/blob/master/3_Algorithm/13_%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5_%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9.md#%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EA%B8%B0%EB%B2%95)
- [이진 검색](https://github.com/SuhyungK/TIL/blob/master/3_Algorithm/13_%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5_%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9.md#%EC%9D%B4%EC%A7%84-%EA%B2%80%EC%83%89)
- [백트래킹](https://github.com/SuhyungK/TIL/blob/master/3_Algorithm/13_%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5_%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9.md#%EC%9D%B4%EC%A7%84-%EA%B2%80%EC%83%89)

## 학습 목표

- 문제를 분할해서 해결하는 분할 정복(*Divide and Conqeur)* 기법을 이해하고 대표적인 알고리즘인 퀵 정렬과 병합 정렬에 대해 학습
- 상태 공간 트리의 모든 노드를 검색하는 백트래킹에 대해 학습
- 이진 트리의 특성을 이해하고 이진 트리의 중요 연산인 탐색, 삽입, 삭제 알고리즘 학습

## 문제 제시 : 가짜 동전 찾기

- n개의 동전들 중에 가짜 동전이 하나 포함되어 있다. 가짜 동전은 진짜 동전에 비해 아주 조금 가볍다. 진짜 동전들의 무게가 동일하다고 할 때 양팔 저울을 이용해서 가짜 동전을 찾아보자.
- 양팔 저울을 최소로 사용해서 가짜 동전을 찾는 방법은 무엇인가?
- 동전이 24개(진짜 23개, 가짜 1개)있다면?

## 분할 정복 기법

- 아우스터리츠 전투에서 나폴레옹이 사용한 전략
- 가운데로 치고 들어가서 한쪽 씩 제거

### 설계 전략

- 분할 (*Divide)*  : 해결할 문제를 여러 개의 작은 부분으로 나눔
- 정복 (*Conquer)* : 나눈 작은 문제를 각각 해결
- 통합 (*Combine) :* (필요하다면) 해결된 해답을 모은다

## 병합 정렬 (Merge Sort)

- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬 최종 결과를 얻어냄
- Top - down 방식
- O ( $nlogn$ )

### 병합 정렬 과정

- 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합

## 퀵 정렬

- 주어진 배열을 두 개로 분할하고, 각각 정렬
- 병합 정렬과 동일?
    - 병합 정렬은 그냥 두 부분을 나누는 반면에, 퀵 정렬은 분할 할 때 기준 아이템(*pivot item)*중심으로, 이보다 작은 건 왼편, 큰 건 오른편에 위치
    - 각 부분 정렬이 끝난 후, 병합 정렬은 병합이라는 후처리 작업이 필요하나, 퀵 정렬은 필요 없음
    
    ```python
    quickSort(A[], l, r):
    	if l < r:
    		s<- partition(A, l, r) # pivot 위치 정하기
    		quickSort(A[], l, s-1)
    		quickSort(A[], s+1, r)
    ```
    

### Hoare-Partition

```python
def partition(l, r):
    pivot = A[l]
    i, j = l, r
    while i <= j:
        while i <= j and A[i] <= pivot:
            i += 1
        while i <= j and A[j] >= pivot:
            j -= 1
        if i < j:
            A[i], A[j] = A[j], A[i]
    A[l], A[j] = A[j], A[l]
    return j

def qsort(l, r):
    if l < r:
        s = partition(l, r)
        qsort(l, s-1)
        qsort(s+1, r)

A = [7, 2, 5, 3, 4, 5]
N = len(A)
qsort(0, N-1)
print(A)

"""
[2, 3, 4, 5, 5, 7]
"""
```

## 이진 검색

- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색 위치 결정
- 목적 키를 찾을 때까지 이진 검색 순환적으로 반복

## 분할 정복의 활용

- 병합 정렬은 외부 정렬의 기본이 되는 정렬 알고리즘
- 퀵 정렬은 매우 큰 입력 데이터에 대해서 좋은 성능을 보이는 알고리즘

## 백트래킹

### N-Queen 문제

- n x n 장기판에서 배치한 퀸들이 서로 위협하지 않도록 n 개의 퀸을 배치하는 문제
- 어떤 두 Queen도 서로를 위협하지 않아야 함
- Queen 을 배치한 n개의 위치는?

### 백트래킹 개념

- 여러 선택지가 존재하는 상황에서 한 가지를 선택
- 선택이 이루어지면 새로운 선택지 집합이 생성됨
- 이런 선택을 반복하면서 최종 상태에 도달

- **당첨 리프 노드 찾기**
    - 루트에서 갈 수 있는 노드 찾기
    - 꽝 노드까지 도달하면 최근 선택으로 되돌아와서 다시 시작
    - 더 이상 선택지가 없다면 이전의 선택지로 돌아가서 다른 선택
    - 루트까지 돌아갔을 경우 더 이상 선택지가 없다면 찾는 답이 없음

- **백트래킹과 깊이 우선 탐색과의 차이**
    - 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 그 경로 버림 → *Prunning*
    - 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로 조기 차단
    - 깊이 우선 탐색을 가하기에는 경우의 수가 너무 많음.
    - 백트래킹도 최악의 경우에는 여전히 지수함수 시간(*Exponential Time*)을 요함