# Git 이란?

## 분산 버전 관리 시스템
버전 관리란? 컴퓨터 소프트웨어의 **특정 상태**들을 관리하는 것이다
- 버전 : 컴퓨터 소프트웨어의 특정한 상태
- 관리 : 소프트웨어를 관리하는 것
- 프로그램 : 컴퓨터에서 실행될 때 특정한 작업을 수행하는 일련의 명령어들의 모음


# GIT의 개념

## GIT 이란?

분산 버전 관리 시스템

버전 관리 프로그램

버전 : 컴퓨터 소프트웨어의 특정한 상태

관리 : 소프트웨어를 관리( 어떤 일의 사무적인 것들, 물건의 유지 또는 보수 개량)

프로그램 : 컴퓨터에서 실행될 때 특정한 작업을 수행하는 일련의 명령어들의 모음

버전 관리?? => 컴퓨터 소프트웨어의 특정 상태들을 관리하는 것이다?

> *ex. 실생활에서의 버전 관리*
> 
> 과제를 제출하기 전날에 한 번 훑으면서 오타나 또는 부족한 내용을 추가한 후에*
> 
> *과제_레포트 최종1.docx_*
> 
> *과제_레포트 최종1.doc*x_
> 
> 파일을 날짜를 통해 관리한다던지 또는 이름을 직접 최종이라는 이름을 하나의 파일에만 부여하는 방식으로 관리해야 한다. 
> 
> *20220718_과제.docx*
> 
> *20220719_과제.docs*
> 
> -> 언제 수정한지는 알겠는데... 어느 부분을 수정했는지...? 
> 
> 그래서 우리가 직접 해야 할 파일들의 수정날짜, 수정내역 이런 것들을 컴퓨터가 스스로 기억하고 우리는 나중에 언제 했는지만 찾아볼 수 있게 해주는 프로그램 ==> **분산 버전 관리 프로그램**

## git 프로그램을 사용하여 버전관리를 한다!!!

### 프로그램의 버전 관리를 git 을 이용해서 한다

버전관리 프로그램 ... 분산...? 

- 중앙집중식 버전 관리 
  
  - 프로그램의 정보를 컴퓨터 하나( 서버 ) 에서만 관리를 하게 되면, 프로그램의 정보가 있는 서버 컴퓨터에 문제가 발생 했을 때, 나머지 그 프로그램을 이용하는 컴퓨터들도 이용을 할 수 없게 됨

- 분산 버전 관리
  
  - 프로그램의 정보를 모든 사람이 개별적으로 가지고 있다. (다른곳에서 가져와서 사용하지 않음)
  
  - 어떤 한 컴퓨터에서 문제가 생겨도 다른 컴퓨터(프로그램의 정보를 가지고 있는)를 통해 프로그램의 정보를 유지할 수 있다

- 분산 버전 관리의 저장소 역할 : github, gitlab
  
  - 인터넷을 통해서 프로그램의 정보를 공유할 수 있게 해준다

- Git 과 Git hub 의 차이
  
  - git :  분산 버전 관리 프로그램
  
  - github, gitlab : git 프로그램을 사용하는 저장소 역할을 지원해주는 서비스(이넡넷을 이용해 원격으로 저장소 역할함)

## Git

- README.md
  
  - **프로젝트에 대한 설명문서
    
    **
    
    - github 프로젝트에서 가장 먼저 보는 문서
    
    - 일반적으로 소프트웨어와 같이 배포되는 파일
    
    - 파일의 확장자 이름 : .md ==> 마크다운 형식 사용

- 현재 README.md 파일이 있는 윈도우 탐색기의 경로(디렉토리), 이 경로를(현재 이 폴더가 있는 공간)을 버전 관리 하겠다.

#### git 명령어

- *git init* : 현재 이 위치를 로컬 저장소로 지정(내 컴퓨터의 저장소 역할을 하도록 한다)

- *ls* : 현재 위치에 내가 버전 관리하고 싶은 파일이 존재하고 있는지 확인
  
  - 현재 위치에 있는 파일들의 목록 출력해주는 명령어

- *git status* : 현재 git 되고 있는 상태를 나타내는 명령어

- *git add* 파일이름 : 해당 파일을 staging area로 이동시켜서 커밋 준비

- *git add* . : 현재 작업 영역(working directory) 에서 버전 관리되고 있지 않은 모든 파일들을 staging area로 이동시킨다.

- *git commit -m "commit message"* : 

- git global ( --global 전역적으로 설정한다 : 다른 디렉토리, 작업영역에서도 지금 내가 설정한 username과 user.email을 통일하게 사용하겠다)
  
  - git config --global user.email "[dddd.ddd@email.com](mailto:dddd.ddd@email.com)"
    
    git config --global user.name "myname"\

- git branch new1 : 브랜치 생성

- git branch -d new1 : 브랜치 생성

- git checkout : 브랜치 변경

- git checkout master : 파일의 원본이 있는 브랜치로 가고 싶다

#### commit (커밋한다)

: 이 파일의 역사(history), 수정 내역, 수정한 날짜, 누가 수정했는지 여부 등을 저장하는 일을 버전관리라고 하는데, **특정 버전으로 남기면 위에 있는 내용들을 기록으로 남긴다고 함 => 커밋한다**

- 3가지 영역을 통해 동작하게 됨

- *working directory* : 내가 작업하고 있는 실제 디렉토리( 버전관리할 파일들이 모여있는 폴더의 위치 )

- *staging area* : 커밋으로 남기고 싶은, 특정 버전으로 관리하고 싶은 파일이 있는 곳 => 커밋할 준비가 되어 있는 파일들이 커밋 되기 전에 존재하는 영역 => 커밋할 준비가 되어 있다 => 버전관리할 파일이다

- *repository* : 어떤 파일을 커밋하게 되면 이 레파지토리 영역에 올라오게 된다
  
  - 커밋들이 저장되는 곳, 버전관리되는 파일들이 **실제로** 저장되는 곳

- *untracked(working directory)* : 실제 디렉토리에 있지만 버전관리되고 있지는 않는 상태
  
  *+git add*

- *tracked(staged; staging area)*
  
  *+git commit*

- *committed(repository)*
  
  -> 수정하게 되면 이제 *modified* 상태

- *nothing added to commit but untracked files present* : 버전 관리되고 있지는 않은 파일이 존재한다

- *changes to be committed* : staging area에 파일이 추가된 상태(git add. 사용 후)

브랜치 master

master : 우리가 커밋을 제일 처음 했을 때 원본이 있는 공간

브랜치 추가

브랜치 new1

new1 : master 브랜치에서 원본 파일들을 그대로 복사해옴

new1 에다가 커밋을 진행 => 그 변경사항은 new1 이라는 브랜치에만 존재

master 브랜치에 있는 원본 파일을 변경내역이 기록되지 않는다

=> 똑같은 작업 영역에 대해서 레포지토리를 두 개 가지고 있는 효과

나중에 merge 브랜치 두개를 합쳐서 통합시킨다

=> new1에 있는 변경사항이 master에 기록이 된다

please tell me who you are... 

: 누군인지 알려주세요, 누구인지 알아야 누가 해당 파일을 커밋했고, 변경사항을 기록했는지 알 수 있어요 

브랜치를 두 개 가지고 있다는 건 레퍼지토리를 여러 개 가지고 있다는 소리

test 해보고 싶을 때 브랜치를 하나 만들어서 test 해보고 결과가 괜찮으면 master랑 merge 하는 방식

>  **로컬 저장소 내용 원격 저장소에 올리기**

- *git remote add origin* <u>*{url}*</u>  원격 저장소에 연결
  
  - remote : 원격 저장소에 어떤 설정을 할 것이다
  
  - add : 원격 저장소에 추가
  
  - origin : 추가할 원격저장소의 이름(주소에다가 이름 붙여주는 것)
  
  - url : 원격 저장소가 위치한 주소(url) 에다가 파일을 저장하겠다 << 이걸로 원격 저장소 식별

- git push origin master: 원격저장소에 올리기
  
  - push : 원격 저장소에 커밋 내용을 동기화시킨다(저장)
  
  - origin : push할 원격 저장소의 이름
  
  - master : 그 저장소의 *어떤 브랜치*에 변경내역을 저장할 것인지 (디폴트 : master)

> **원격 레포지토리에 있는 내용 가져오기**

- git clone (shift + insert;붙여넣기) {url}
  
  : 최초 1번만 실행하는 명령어
  
  : 이미 init 되어 있는 다른 repository 를 복사해서 가져오겠다

> **수정**
> 
> : 내가 push를 해서 원격 저장소에 변경내역을 저장했다
> 
> 다른 컴퓨터의 사용자는 해당 변경내역을 어떻게 최신화 할 수 있는가?? 

- *git pull origin master*
  
  :다른 사람들이 변경한 내역을 가져올 때
  
  : 지금 이 경로에 이미 repostiory가 init 되어 있거나 clone 되어 있는 상태에서 현재 내 파일이 오래 되었을 수도 있으니, 다른 사람들이 원격 저장소에 저장한 변경 내역들을 가져와서 내 파일들을 최신화 시키겠다
  
  - 변경한 적이 있을 때마다 실행되어지는 명령어가 된다. 
  
  다른 사람들이 push를 통해서 원격 저장소에 변경 내역을 저장하면 -> 나는 pull 을 통해 다른 사람들이 저장한 변경내역을 내 로컬 레포지토리로 가져와서 최신화하겠다
1. git init : 현재 내가 작업하고 있는 영역을 repostiory로 사용한다. 

2. git add : 현재 내가 작업하고 있는 영역의 모든 파일을 버전관리하겠다

3. git commit -m 'commit message' : 메세지를 남겨서 변경내역을 저장하겠다

4. git remote add orgin "url" : 원격저장소의 url을 이용해서 해당 원격 저장소에 현재 작업하고 있는 로컬 저장소(init 명령어를 실행한 곳)을 연동하는 명령어

5. git push origin master : 원격 저장소에 현재 커밋한 내역(변경사항 최신화)

다른 곳으로 레포지토리 복사 

1. git clone  "url" : 해당 url을 가진 원격 저장소 내의 파일들을 복사해온다

2. git pull origin master : origin 이라는 이름을 가진 원격 저장소에서 master브랜치에 있는 파일들을 최신화하겠다